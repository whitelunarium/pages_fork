---
layout: opencs
---
<meta name="gemini-api-key" content="AIzaSyDM-_Gj6GQTXHcym9cP_syUeopcF25x47o"> 

<div class="lesson-container">
  <!-- Sidebar with Lesson Links -->
  <aside class="lesson-sidebar">
    <h3>üéÆ Solitaire Lessons</h3>
    <ul>
      <li><a href="{{site.baseurl}}/solitaire/lesson/frontend">Lesson 1: Frontend</a></li>
      <li><a href="{{site.baseurl}}/solitaire/lesson/oop">Lesson 2: JavaScript OOP</a></li>
      <li><a href="{{site.baseurl}}/solitaire/lesson/problem-solving">Lesson 3: Problem Solving</a></li>
    </ul>
  
    <h3>üí° Future References</h3>
    <ul>
      <li><a href="{{site.baseurl}}/solitaire/lesson/future-references">Future Reference Tags</a></li>
    </ul>

    <h3>üéØ End of Lesson</h3>
    <ul>
      <li><a href="{{site.baseurl}}/solitaire/lesson/quiz">End of Lesson Quiz</a></li>
    </ul>
    <hr>

    <!-- Time Tracker -->
    <h4>‚è±Ô∏è Study Time</h4>
    <div class="time-display">
      <span id="total-time">0:00</span>
      <small>on this lesson</small>
    </div>
    <div id="timer-status" class="timer-status">Active</div>

    <hr>

    <!-- Progress Tracker -->
    <h4>üìä Your Progress</h4>
    <div class="progress-bar">
      <div class="progress-fill" id="lesson-progress"></div>
    </div>
    <p id="progress-text">0% complete</p>
    <button id="reset-progress" class="btn small-btn">Reset Progress</button>

    <hr>

    <!-- Badges -->
    <h4>üèÖ Your Badges</h4>
    <p id="badges">No badges yet...</p>
  </aside>

  <!-- Main Lesson Content -->
  <main class="lesson-content">
    <h1>{{ page.title }}</h1>
    <div class="post-content">
      {{ content }}
    </div>

    <hr>

    <!-- Sandbox -->
    <div class="sandbox">
      <h3>üñ•Ô∏è Try It Yourself</h3>
      <textarea id="sandbox-code">
// Example: Flip a card
let card = { rank: "A", suit: "Spades", faceUp: false };
card.faceUp = true;
console.log(card);
      </textarea>
      <button id="run-sandbox">Run Code</button>
      <pre id="sandbox-output"></pre>
    </div>

    <hr>

    <!-- Reflection & Quiz -->
    <div class="lesson-quiz">
      <h3>üìù Quick Check</h3>
      <p>What's one key idea you learned from this lesson?</p>
      <textarea id="reflection-box" placeholder="Type your reflection or answer here..."></textarea>
      <button id="save-reflection">Save</button>
      <p id="reflection-status"></p>
    </div>

    <hr>

    <!-- Resources -->
    <div class="resources">
      <h3>üìö Related Resources</h3>
      <ul>
        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank">MDN: JavaScript Classes</a></li>
        <li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank">CSS Tricks: Flexbox Guide</a></li>
        <li><a href="https://javascript.info/" target="_blank">The Modern JavaScript Tutorial</a></li>
      </ul>
    </div>

    <!-- Navigation -->
    <div class="lesson-nav">
      {% if page.prev_url %}<a href="{{ page.prev_url }}" class="btn">‚¨Ö Previous</a>{% endif %}
      {% if page.next_url %}<a href="{{ page.next_url }}" class="btn">Next ‚û°</a>{% endif %}
    </div>
  </main>
</div>

<script>
// Time Tracker Globals
let startTime = Date.now();
let totalTime = parseInt(localStorage.getItem(`lesson-time-${window.location.pathname.split("/").pop()}`)) || 0;
let isActive = true;
const currentLesson = window.location.pathname.split("/").pop() || 'lesson';
const MIN_TIME_FOR_BADGE = 60000; // 1 minute

// Reflection save
const saveBtn = document.getElementById("save-reflection");
const box = document.getElementById("reflection-box");
const status = document.getElementById("reflection-status");
const refKey = "reflection-" + currentLesson;
box.value = localStorage.getItem(refKey) || "";

saveBtn.addEventListener("click", () => {
  localStorage.setItem(refKey, box.value);
  status.textContent = "Saved!";
  setTimeout(() => status.textContent = "", 1500);

  // Unlock badge immediately when reflection is saved
  unlockBadge(currentLesson);
});


function formatTime(milliseconds) {
  const seconds = Math.floor(milliseconds / 1000);
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function updateDisplay() {
  if (isActive) {
    const currentTime = totalTime + (Date.now() - startTime);
    document.getElementById('total-time').textContent = formatTime(currentTime);

    // Badge unlock check
    if (currentTime >= MIN_TIME_FOR_BADGE) {
      unlockBadge(currentLesson);
    }
  }
}

function pause() {
  if (isActive) {
    totalTime += Date.now() - startTime;
    isActive = false;
    document.getElementById('timer-status').textContent = 'Paused';
    document.getElementById('timer-status').className = 'timer-status paused';
    saveTime();
  }
}

function resume() {
  if (!isActive) {
    startTime = Date.now();
    isActive = true;
    document.getElementById('timer-status').textContent = 'Active';
    document.getElementById('timer-status').className = 'timer-status active';
  }
}

function saveTime() {
  localStorage.setItem(`lesson-time-${currentLesson}`, totalTime);
}

// Update every second
setInterval(updateDisplay, 1000);

// Pause/resume on visibility change
document.addEventListener('visibilitychange', () => {
  if (document.hidden) pause();
  else resume();
});

// Save before leaving
window.addEventListener('beforeunload', () => {
  if (isActive) {
    totalTime += Date.now() - startTime;
    saveTime();
  }
});

// --------------- BADGES ---------------
function unlockBadge(lesson) {
  let badges = JSON.parse(localStorage.getItem("lesson-badges")) || [];

  if (!badges.includes(lesson)) {
    badges.push(lesson);
    localStorage.setItem("lesson-badges", JSON.stringify(badges));

    renderBadges(badges);
    showCongratsPopup(lesson);
  }
}

function renderBadges(badges) {
  const badgeContainer = document.getElementById("badges");
  badgeContainer.innerHTML = "";

  const icons = {
    "frontend": "üíª",
    "oop": "üß©",
    "problem-solving": "üß†",
    "future-references": "üìñ",
    "lesson": "üèÖ"
  };

  badges.forEach(b => {
    const badge = document.createElement("span");
    badge.className = "badge";
    badge.innerHTML = `${icons[b] || "üèÖ"} ${b.replace("-", " ")}`;
    badgeContainer.appendChild(badge);
  });
}

function showCongratsPopup(lesson) {
  const popup = document.createElement("div");
  popup.className = "congrats-popup";
  popup.innerHTML = `üéâ Congrats! You earned a badge for <b>${lesson.replace("-", " ")}</b>`;

  document.body.appendChild(popup);
  setTimeout(() => popup.classList.add("show"), 50);

  setTimeout(() => {
    popup.classList.remove("show");
    setTimeout(() => popup.remove(), 300);
  }, 3000);
}

// On load
document.addEventListener("DOMContentLoaded", () => {
  // Render saved badges
  let savedBadges = JSON.parse(localStorage.getItem("lesson-badges")) || [];
  renderBadges(savedBadges);
});

document.addEventListener("DOMContentLoaded", () => {
  // Render saved badges
  let savedBadges = JSON.parse(localStorage.getItem("lesson-badges")) || [];
  renderBadges(savedBadges);

  // ---------------- PROGRESS TRACKER ----------------
  const lessons = ["frontend", "oop", "problem-solving", "future-references"];
  const key = "lesson-progress";
  let progress = JSON.parse(localStorage.getItem(key)) || {};

  // mark current lesson as complete
  if (currentLesson) progress[currentLesson] = true;
  localStorage.setItem(key, JSON.stringify(progress));

  let done = Object.keys(progress).length;
  let percent = Math.floor((done / lessons.length) * 100);

  document.getElementById("lesson-progress").style.width = percent + "%";
  document.getElementById("progress-text").textContent = percent + "% complete";

  // reset progress button
  document.getElementById("reset-progress").onclick = () => {
    if (confirm("Reset all progress and time data?")) {
      localStorage.removeItem(key);
      localStorage.removeItem("lesson-badges");
      
      // clear all lesson times
      lessons.forEach(lesson => {
        localStorage.removeItem(`lesson-time-${lesson}`);
      });

      document.getElementById("lesson-progress").style.width = "0%";
      document.getElementById("progress-text").textContent = "0% complete";
      document.getElementById("badges").textContent = "No badges yet...";
      location.reload();
    }
  };
});

</script>

<style>
.lesson-container {
  display: flex;
  gap: 2rem;
}
.lesson-sidebar {
  flex: 0 0 250px;
  background: #1f2020;
  padding: 1rem;
  border-radius: 8px;
  position: sticky;
  top: 1rem;
  height: fit-content;
  color: #f0f0f0;
}
.lesson-content {
  flex: 1;
}

/* Time Tracker Styles */
.time-display {
  background: #2a2d2d;
  padding: 0.5rem;
  margin: 0.25rem 0;
  border-radius: 4px;
  text-align: center;
}
.time-display span {
  font-size: 1.2rem;
  font-weight: bold;
  color: #4cafef;
  display: block;
}
.time-display small {
  font-size: 0.75rem;
  color: #aaa;
}
.timer-status {
  text-align: center;
  padding: 0.25rem;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: bold;
  margin-top: 0.5rem;
}
.timer-status.active {
  background: #2d5a3d;
  color: #4ade80;
}
.timer-status.paused {
  background: #5a3d2d;
  color: #fbbf24;
}

.progress-bar {
  background: #333;
  border-radius: 6px;
  height: 12px;
  width: 100%;
  margin: 0.5rem 0;
}
.progress-fill {
  background: #4cafef;
  height: 100%;
  width: 0%;
  border-radius: 6px;
}
.copy-btn {
  position: absolute;
  top: 5px;
  right: 5px;
  padding: 3px 8px;
  font-size: 0.8rem;
  cursor: pointer;
}
.lesson-quiz textarea {
  width: 100%;
  min-height: 80px;
  margin: 0.5rem 0;
}
.btn {
  display: inline-block;
  background: #007acc;
  color: white;
  padding: 6px 12px;
  border-radius: 4px;
  text-decoration: none;
  margin: 0.5rem;
  border: none;
  cursor: pointer;
}
.btn:hover {
  background: #005fa3;
}
.small-btn {
  font-size: 0.75rem;
  padding: 3px 6px;
  margin-top: 0.5rem;
}
.sandbox textarea {
  width: 100%;
  height: 120px;
  font-family: monospace;
  margin-bottom: 0.5rem;
}
.resources, .sandbox, .lesson-quiz {
  background: #2b2b2b;
  padding: 1rem;
  border-radius: 8px;
  margin: 1rem 0;
  color: #f0f0f0;
}
#badges {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}
.badge {
  background: #333;
  color: #fff;
  padding: 6px 10px;
  border-radius: 20px;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  gap: 5px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}

/* Congrats Popup */
.congrats-popup {
  position: fixed;
  top: 20px;
  right: -300px;
  background: #222;
  color: #fff;
  padding: 12px 18px;
  border-radius: 8px;
  font-weight: bold;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  transition: right 0.3s ease, opacity 0.3s ease;
  opacity: 0.95;
  z-index: 9999;
}
.congrats-popup.show {
  right: 20px;
}
</style>
<script type="module">
// ---------- Helpers to pull lesson metadata ----------
function readLessonConfig() {
  try {
    const el = document.getElementById("lesson-config");
    if (!el) return null;
    return JSON.parse(el.textContent || "{}");
  } catch { return null; }
}

function extractKeyPointsFromDOM() {
  const root = document.querySelector(".post-content");
  if (!root) return [];

  // Find a heading that likely precedes key points
  const headings = Array.from(root.querySelectorAll("h2,h3"));
  let list = null;
  const want = /key\s*points|takeaways|what\s*you\s*learned|summary/i;

  const targetHeading = headings.find(h => want.test(h.textContent));
  if (targetHeading) {
    // Next sibling UL/OL after the heading
    let n = targetHeading.nextElementSibling;
    while (n && !/UL|OL/.test(n.tagName)) n = n.nextElementSibling;
    if (n && /UL|OL/.test(n.tagName)) list = n;
  }

  // Fallback: first UL/OL in the post
  if (!list) list = root.querySelector("ul,ol");
  if (!list) return [];

  return Array.from(list.querySelectorAll("li"))
    .map(li => li.innerText.trim())
    .filter(Boolean)
    .slice(0, 12);
}

function getRubricDefault() {
  return [
    "definitions_or_vocabulary",
    "examples_or_code_snippets",
    "accuracy_of_explanations",
    "ties_to_lesson_objectives"
  ];
}

// ---------- Public API used by your scorer ----------
function gatherLessonSignals() {
  const cfg = readLessonConfig();
  const keyPoints = (cfg?.key_points && Array.isArray(cfg.key_points) && cfg.key_points.length)
    ? cfg.key_points
    : extractKeyPointsFromDOM();

  const rubricCriteria = (cfg?.rubric_criteria && Array.isArray(cfg.rubric_criteria) && cfg.rubric_criteria.length)
    ? cfg.rubric_criteria
    : getRubricDefault();

  const lessonEl = document.querySelector(".post-content");
  const lessonText = lessonEl ? lessonEl.innerText : "";
  const title = (document.querySelector(".lesson-content h1")?.innerText || "").trim();

  return { keyPoints, rubricCriteria, lessonText, title };
}

// ---------- Prompt factory (reusable for all lessons) ----------
export function buildScoringPrompt({ lessonText, responseText, keyPoints, rubricCriteria, title }) {
  const kp = keyPoints?.length ? keyPoints.map((s, i) => `${i+1}. ${s}`).join("\n") : "N/A";

  const rubricJoined = JSON.stringify(rubricCriteria || getRubricDefault());

  return `
You are grading a student's short reflection after a lesson titled: "${title}".

Use ONLY:
1) The lesson's key points (below), and
2) The student's response.

Return STRICT JSON with:
- "score": integer 0‚Äì100 (basic = 0‚Äì39, emerging = 40‚Äì59, proficient = 60‚Äì84, advanced = 85‚Äì100)
- "reasoning": 1‚Äì3 sentences, concise and specific
- "tips": 2‚Äì4 concrete improvement tips as an array of short strings
- "rubricCriteria": subset of ${rubricJoined} that the student actually demonstrated

Be strict on correctness and specificity. Reward answers that reference the key points or give relevant examples.
Penalize vague statements or unrelated content.

KEY_POINTS:
${kp}

LESSON_CONTEXT (optional backup; do not quote verbatim if key points suffice):
"""${(lessonText || "").slice(0, 28000)}"""

STUDENT_RESPONSE:
"""${(responseText || "").slice(0, 4000)}"""
  `.trim();
}

// If you‚Äôre calling scoreWithGemini() elsewhere, just swap in:
// const { keyPoints, rubricCriteria, lessonText, title } = gatherLessonSignals();
// const prompt = buildScoringPrompt({ lessonText, responseText, keyPoints, rubricCriteria, title });

</script>

<script type="module">
/**
 * Minimal client-only Gemini scorer for lessons (reusable across pages).
 * No backend required. Saves to localStorage now; easy to POST later.
 */

/* ---------------------------- API KEY HELPERS ---------------------------- */
// You can swap this to the meta tag if you prefer build-time injection
function getApiKey() {
  const input = document.getElementById("gemini-key");
  if (input && input.value.trim()) return input.value.trim();
  const meta = document.querySelector('meta[name="gemini-api-key"]');
  return meta?.content?.trim() || "";
}

/* ------------------------------ PAGE HELPERS ----------------------------- */
function getLessonAndResponse() {
  const lessonEl = document.querySelector(".post-content");
  const reflectionEl = document.getElementById("reflection-box");
  return {
    lessonText: lessonEl ? lessonEl.innerText : "",
    responseText: reflectionEl ? reflectionEl.value.trim() : ""
  };
}

// Attach a small UI: a button + a results box
(function attachScoringUI() {
  const quiz = document.querySelector(".lesson-quiz");
  if (!quiz) return;

  const btn = document.createElement("button");
  btn.id = "score-reflection";
  btn.className = "btn";
  btn.textContent = "ü§ñ Get AI Score";

  const out = document.createElement("div");
  out.id = "ai-score-output";
  out.style.marginTop = ".5rem";

  quiz.appendChild(btn);
  quiz.appendChild(out);
})();

/* ---------------------- LESSON SIGNALS & PROMPT BUILDER ------------------ */
// Optional per-lesson config exposed via:
// script id="lesson-config" type="application/json">{ ... }
function readLessonConfig() {
  try {
    const el = document.getElementById("lesson-config");
    if (!el) return null;
    return JSON.parse(el.textContent || "{}");
  } catch {
    return null;
  }
}

function extractKeyPointsFromDOM() {
  const root = document.querySelector(".post-content");
  if (!root) return [];

  // Prefer lists under headings like ‚ÄúKey Points‚Äù, ‚ÄúTakeaways‚Äù, etc.
  const headings = Array.from(root.querySelectorAll("h2,h3"));
  const want = /key\s*points|takeaways|what\s*you\s*learned|summary/i;

  let list = null;
  const targetHeading = headings.find(h => want.test(h.textContent));
  if (targetHeading) {
    let n = targetHeading.nextElementSibling;
    while (n && !/UL|OL/.test(n.tagName)) n = n.nextElementSibling;
    if (n && /UL|OL/.test(n.tagName)) list = n;
  }

  // Fallback: first UL/OL on the page
  if (!list) list = root.querySelector("ul,ol");
  if (!list) return [];

  return Array.from(list.querySelectorAll("li"))
    .map(li => li.innerText.trim())
    .filter(Boolean)
    .slice(0, 12);
}

function getRubricDefault() {
  return [
    "definitions_or_vocabulary",
    "examples_or_code_snippets",
    "accuracy_of_explanations",
    "ties_to_lesson_objectives"
  ];
}

function gatherLessonSignals() {
  const cfg = readLessonConfig();

  const keyPoints = (cfg?.key_points && Array.isArray(cfg.key_points) && cfg.key_points.length)
    ? cfg.key_points
    : extractKeyPointsFromDOM();

  const rubricCriteria = (cfg?.rubric_criteria && Array.isArray(cfg.rubric_criteria) && cfg.rubric_criteria.length)
    ? cfg.rubric_criteria
    : getRubricDefault();

  const lessonEl = document.querySelector(".post-content");
  const lessonText = lessonEl ? lessonEl.innerText : "";
  const title = (document.querySelector(".lesson-content h1")?.innerText || "").trim() || (cfg?.title || document.title);

  return { keyPoints, rubricCriteria, lessonText, title };
}

function buildScoringPrompt({ lessonText, responseText, keyPoints, rubricCriteria, title }) {
  const kp = keyPoints?.length ? keyPoints.map((s, i) => `${i+1}. ${s}`).join("\n") : "N/A";
  const rubricJoined = JSON.stringify(rubricCriteria || getRubricDefault());

  return `
You are grading a student's short reflection after a lesson titled: "${title}".

Use ONLY:
1) The lesson's key points (below), and
2) The student's response.

Return STRICT JSON with:
- "score": integer 0‚Äì100 (basic = 0‚Äì39, emerging = 40‚Äì59, proficient = 60‚Äì84, advanced = 85‚Äì100)
- "reasoning": 1‚Äì3 sentences, concise and specific
- "tips": 2‚Äì4 concrete improvement tips as an array of short strings
- "rubricCriteria": subset of ${rubricJoined} that the student actually demonstrated

Be strict on correctness and specificity. Reward answers that reference the key points or give relevant examples.
Penalize vague statements or unrelated content.

KEY_POINTS:
${kp}

LESSON_CONTEXT (optional backup; do not quote verbatim if key points suffice):
"""${(lessonText || "").slice(0, 28000)}"""

STUDENT_RESPONSE:
"""${(responseText || "").slice(0, 4000)}"""
`.trim();
}


/* ----------------------------- GEMINI CLIENT ----------------------------- */
async function backoffFetch(url, options, retries = 2, baseDelayMs = 1200) {
  for (let i = 0; i <= retries; i++) {
    const res = await fetch(url, options);
    if (res.status !== 429) return res;
    if (i === retries) return res;
    await new Promise(r => setTimeout(r, baseDelayMs * (i + 1)));
  }
}

async function scoreWithGemini(apiKey, promptText, model = "gemini-1.5-flash") {
  if (!apiKey) throw new Error("Missing Gemini API key.");
  const endpoint =
    `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=` +
    encodeURIComponent(apiKey);

  const body = {
    contents: [{ role: "user", parts: [{ text: promptText }]}],
    generationConfig: {
      temperature: 0.2,
      maxOutputTokens: 400,
      responseMimeType: "application/json"
    }
  };

  const res = await backoffFetch(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!res?.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`Gemini error (${res?.status || "?"}): ${txt || res?.statusText || "Unknown error"}`);
  }

  const data = await res.json();
  const text = data?.candidates?.[0]?.content?.parts?.[0]?.text || "{}";
  // Be robust to accidental trailing commentary:
  const jsonStart = text.indexOf("{");
  const jsonEnd = text.lastIndexOf("}");
  const clean = jsonStart !== -1 ? text.slice(jsonStart, jsonEnd + 1) : "{}";
  return JSON.parse(clean);
}

/* --------------------------- STORAGE & RENDERING ------------------------- */
function persistScore(lessonKey, payload) {
  const key = `score-${lessonKey}`;
  const record = {
    ...payload,
    ts: Date.now(),
    rubricVersion: 1
  };
  localStorage.setItem(key, JSON.stringify(record));
  return record;
}

function renderScore(targetEl, payload) {
  targetEl.innerHTML = `
    <div style="background:#1f2020;border:1px solid #333;border-radius:8px;padding:12px;">
      <strong>AI Score:</strong> ${payload.score}/100
      <div style="opacity:.85;margin-top:.25rem">${payload.reasoning || ""}</div>
      ${
        Array.isArray(payload.tips) && payload.tips.length
          ? `<div style="margin-top:.5rem"><em>Tips:</em><ul>${payload.tips
              .map(t => `<li>${t}</li>`)
              .join("")}</ul></div>`
          : ""
      }
    </div>
  `;
}

/* --------------------------------- MAIN ---------------------------------- */
document.addEventListener("DOMContentLoaded", () => {
  const scoreBtn = document.getElementById("score-reflection");
  const out = document.getElementById("ai-score-output");
  if (!scoreBtn || !out) return;

  // Optional: display any previous score for this lesson
  const current = window.location.pathname.split("/").pop();
  const existing = localStorage.getItem(`score-${current}`);
  if (existing) {
    try { renderScore(out, JSON.parse(existing)); } catch {}
  }

  scoreBtn.addEventListener("click", async () => {
    out.textContent = "Scoring with Gemini‚Ä¶";
    try {
      const apiKey = getApiKey();
      const { lessonText, responseText } = getLessonAndResponse();
      if (!responseText) throw new Error("Please write your reflection first.");

      const signals = gatherLessonSignals();
      const promptText = buildScoringPrompt({
        lessonText,
        responseText,
        keyPoints: signals.keyPoints,
        rubricCriteria: signals.rubricCriteria,
        title: signals.title
      });
      
      console.log("Generated Gemini prompt:\n", promptText);

      const result = await scoreWithGemini(apiKey, promptText, /* model */ "gemini-1.5-flash");

      // Normalize fields just in case
      const payload = {
        score: Math.max(0, Math.min(100, parseInt(result.score ?? 0, 10))),
        reasoning: String(result.reasoning ?? ""),
        tips: Array.isArray(result.tips) ? result.tips.slice(0, 4).map(String) : [],
        rubricCriteria: Array.isArray(result.rubricCriteria) ? result.rubricCriteria : []
      };

      const saved = persistScore(current, payload);
      renderScore(out, saved);

      // (Future) You‚Äôll POST `saved` to your backend to store in a blob/table.
      // e.g., await fetch('/api/lesson-scores', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(saved) })

    } catch (err) {
      out.textContent = "‚ùå " + (err?.message || err);
    }
  });
});
</script>
